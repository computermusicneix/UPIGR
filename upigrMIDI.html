<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>uPIGr-ATS-1 MIDI</title>

<link rel="shortcut icon" href="../upigr_images/favicon_pig.png">

<script src="./upigr_addons/Tone.js" type="text/javascript"></script>
<script src="./upigr_addons/teoria.js" type="text/javascript"></script>
<script src="./upigr_addons/p5.js" type="text/javascript"></script>

<!--<script src="./upigr_addons/hnl.mobileconsole.js" type="text/javascript"></script>-->

<link rel="stylesheet" href="./upigr_addons/hnl.mobileconsole.css">

<!– MIDI ->
<script src="./upigr_addons/webmidi.iife.min.js" type="text/javascript"></script>

<meta name='viewport'
     content='width=device-width, initial-scale=1.0, maximum-scale=1.0,
     user-scalable=0' >

<style>

body {background-color: black;}

* {
  box-sizing: border-box;
}

#canvas{
	margin:3px;
	width: 100%;
	height: 50vh;
}

#post{
 	margin:3px;
 	width: 100%;
	height: 30vh;
}

#editor{
 	margin:3px;
 	width: 100%;
	height: 78vh;
}

#command{
 	width: 100%;
  	margin:3px;
}

#audio{
 	width: 100%;
  	margin:3px;
}


.column {
  float: left;
  padding: 3px;
}

.left {
  width: 30%;
}

.right {
  width: 70%;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

@media screen and (max-width: 600px) {
  .column {
    width: 100%;
  }

#canvas{
	margin:3px;
	width: 100%;
	height: 33vh;
}

#post{
 	margin:3px;
 	width: 100%;
	height: 33vh;
}

#editor{
 	margin:3px;
 	width: 100%;
	height: 33vh;
}

#command{
 	width: 100%;
  	margin:3px;
}

#audio{
 	width: 100%;
  	margin:3px;
}

}




</style>

</head>

<body>

<div class="row">
<div class="column left">

	<div id="editor"></div>
	<div id="command"></div>

</div>   
   
<div class="column right">

	<div id="canvas"></div>
	<div id="post"></div>
	

</div>
</div>

<input type="file" name="" id='input_file' hidden>

<script src="/upigr_addons/src-noconflict/ace.js" type="text/javascript" charset="utf-8"></script>
<script src="/upigr_addons/src-noconflict/ext-language_tools.js" type="text/javascript" charset="utf-8"></script>


<script>


    let leftMemory = [];
    let rightMemory = [];
    let rearMemory = [];
    let frontMemory = [];
    
    let leftMemoryPattern = [];
    let rightMemoryPattern = [];
    let rearMemoryPattern = [];
    let frontMemoryPattern = [];
    
    let leftMemoryDrone = [];
    let rightMemoryDrone = [];
    let rearMemoryDrone = [];
    let frontMemoryDrone = [];
    
    var canvasArea = document.getElementById('canvas');
    canvasWidth = canvasArea.offsetWidth;
    canvasHeight = canvasArea.offsetHeight;
    
    // Enable MIDI
    
    WebMidi.enable().then(onEnabled).catch(err => alert(err));

    let MIDIoutput1;
    let MIDIchannel1; // rear
    let MIDIchannel2; // left
    let MIDIchannel3; // right
    let MIDIchannel4; // front

    // p5 canvas
    
    let drawing = "imageMode(CENTER);image(img, width / 2, height / 2, img.width/2, img.height/2);";
    
    var canvas;
    
    function setup(){
        canvas = createCanvas(canvasWidth, canvasHeight);
	canvas.parent('canvas');
	
        img = loadImage('../upigr_images/uPIGr_pig.png');
	
    }

    function draw() {
      //background(0);
      eval(drawing);
    }
    
    function windowResized() {
      canvasWidth = document.getElementById("canvas").offsetWidth;
      canvasHeight = document.getElementById("canvas").offsetHeight;
      resizeCanvas(canvasWidth, canvasHeight);
    }
    
    // Code editor

    var editor = ace.edit("editor");
    editor.setTheme("ace/theme/twilight");
    editor.session.setMode("ace/mode/javascript");
    
    var langTools = ace.require("ace/ext/language_tools");

    editor.setOptions({
      enableBasicAutocompletion: true,
      enableLiveAutocompletion: true,
      enableSnippets: true,
    });
    
    editor.session.setUseWrapMode(true);
    
    // autocomplete on editors
    
    var myList = [
	    "left();",
	    "right();",
	    "rear();",
	    "front();",
	    "loadInstrument();",
	    "title();",
	    "date();",
	    "randomNoteRear();",
	    "randomNoteLeft();",
	    "randomNoteRight();",
	    "randomNoteFront();",
	    "xRandomNoteRear();",
	    "xRandomNoteLeft();",
	    "xRandomNoteRight();",
	    "xRandomNoteFront();",
	    "getRear();",
	    "getLeft();",
	    "getRight();",
	    "getFront();",
	    "showHistory",
	    "initScore",
	    "saveScore",
	    "openScore",
		  "insert",
	    "openplayScore",
	    "playScore",
	    "openSynth",
	    "fullCanvas",
	    "fullCanvasSynth",
	    "rearLen",
	    "leftLen",
	    "rightLen",
	    "frontLen",
	    "rearScoreLen",
	    "rightScoreLen",
	    "leftScoreLen",
	    "frontScoreLen",
	    "connectMIDI",
	    "..",
	    "in stopAll",
	    "in playAll",
	    "in stopRear",
	    "in stopLeft",
	    "in stopRight",
	    "in stopFront",
	    "in forLoop"
    ]

    var myCompleter = {
	    identifierRegexps: [/[^\s]+/],
	    getCompletions: function(editor, session, pos, prefix, callback) {
		//console.info("myCompleter prefix:", prefix);
		callback(
			null,
			myList.filter(entry=>{
				return entry.includes(prefix);
			}).map(entry=>{
				return {
					value: entry
				};
			})
		);
	    }
    }

    langTools.addCompleter(myCompleter);
    
    editor.setValue("Editor window.")


    // Command
    
	var command = ace.edit("command");

	command.setOptions({
		    maxLines: 1,
		    autoScrollEditorIntoView: true,
		    highlightActiveLine: false,
		    printMargin: false,
		    showGutter: false,
		    mode: "ace/mode/javascript",
		    theme: "ace/theme/monokai",
		    enableBasicAutocompletion: true,
            enableLiveAutocompletion: true,
            enableSnippets: true,
	});
	
    let command_history = [];
    let code = "";
    
    let code_history = [];
    let code_score = [];

    let newCode = [];


    command.commands.addCommand({
	    name: "myCommand",
	    bindKey: { win: "Enter", mac: "Enter" },
      exec: function() {
	       code = command.getValue();
	       parser(code);
	       command_history.push(command.getValue());
	       command.setValue("");
    }
    });
    
    
    let started = 0;
    let scoreState = 0;
    let startTime;
    
    command.on("focus", function(){
        if(started == 0){
            started = 1;
        }
    });
    
    command.setValue("Command window.");
    
    function parser(code){

	    codeS = code.split(" ");
	    //console.log(codeS);
	    
	    // Connect MIDI (TODO :añadir 4 canales)
	    
	    if(codeS[0] == "connectMIDI"){
	    
	    	MIDIoutput1 = WebMidi.outputs[codeS[1]];
	    	MIDIchannel1 = MIDIoutput1.channels[1];
	    	MIDIchannel2 = MIDIoutput1.channels[2];
	    	MIDIchannel3 = MIDIoutput1.channels[3];
	    	MIDIchannel4 = MIDIoutput1.channels[4];
	    	console.log("Connected to id: "+codeS[1])
			
	    };
	    
	    // showHistory (show code history)
	    if(codeS[0] == "showHistory"){
	        histo = "";
	        for(let i=0;i<code_history.length;i++){
	              
	              histo += i+" "+code_history[i]+"\n";
	        };
	        post.setValue(histo);
	      
	    };
	    
	    // init score
	    
	    if(codeS[0] == "initScore"){
	        scoreState = 1;
	        startTime = new Date();
	        post.setValue(".. Score init ..");
	    };
	    
	    // saveScore
	    
	    if(codeS[0] == "saveScore"){
	    	scoreState = 0;
	        saveScore(codeS[1]);
	     };
	    // insert (insert code on editor)
	     	     
	    if(codeS[0] == "insert"){
	        document.getElementById('input_file').click();
            document.getElementById('input_file').addEventListener('change', insertonEditor, false);
	    }; 

	    
	    // open and play score
	     	     
	    if(codeS[0] == "openplayScore"){
	        document.getElementById('input_file').click();
            document.getElementById('input_file').addEventListener('change', openplayScore, false);
	    }; 
	     
	     // playScore
	     
	    if(codeS[0] == "playScore"){
	        repeatscore = 1;
	        indexscore  = 0;
	        scoreCounter();
	    }; 
	    if(codeS[0] == "openScore"){
	        document.getElementById('input_file').click();
            document.getElementById('input_file').addEventListener('change', openScore, false);
	    };
	    if(codeS[0] == "openSynth"){
	        document.getElementById('input_file').click();
            document.getElementById('input_file').addEventListener('change', openSynth, false);
	    };
	    // help (show help)
	    if(codeS[0] == "help"){
	        post.setValue(help_list);
	    };
	    if(codeS[0] == "functions"){
	         post.setValue(functions_list);
	         
	    }
	    if(codeS[0] == "commands"){
	        post.setValue(commands_list);
	    };
	    if(codeS[0] == "snippets"){
	        post.setValue(snippets_list);
	    };
	    if(codeS[0] == "variables"){
	        post.setValue(variables_list);
	    };
	    if(codeS[0] == "leftLen"){
	    	let posting = leftMemory.length.toString();
	        post.setValue("Length of left memory: "+posting);
	    };
	    if(codeS[0] == "rightLen"){
	    	let posting = rightMemory.length.toString();
	        post.setValue("Length of right memory: "+posting);
	    };
	    if(codeS[0] == "rearLen"){
	    	let posting = rearMemory.length.toString();
	        post.setValue("Length of rear memory: "+posting);
	    };

	    if(codeS[0] == "frontLen"){
	    	let posting = frontMemory.length.toString();
	        post.setValue("Length of front memory: "+posting);
	    };
	    
	    if(codeS[0] == "rearScoreLen"){
	    	let posting = rearScore.length.toString();
	        post.setValue("Length of rear score: "+posting);
	    };
	    
	    if(codeS[0] == "leftScoreLen"){
	    	let posting = leftScore.length.toString();
	        post.setValue("Length of left score: "+posting);
	    };
	    
	    if(codeS[0] == "rightScoreLen"){
	    	let posting = rearScore.length.toString();
	        post.setValue("Length of right score: "+posting);
	    };
	    
	    if(codeS[0] == "frontScoreLen"){
	    	let posting = rearScore.length.toString();
	        post.setValue("Length of front score: "+posting);
	    };
	    if(codeS[0] == "leftPatternLen"){
	    	let posting = leftMemoryPattern.length.toString();
	        post.setValue("Length of left pattern memory: "+posting);
	    };
	    if(codeS[0] == "rightPatternLen"){
	    	let posting = rightMemoryPattern.length.toString();
	        post.setValue("Length of right pattern memory: "+posting);
	    };
	    if(codeS[0] == "rearPatternLen"){
	    	let posting = rearMemoryPattern.length.toString();
	        post.setValue("Length of rear pattern memory: "+posting);
	    };
	    if(codeS[0] == "frontPatternLen"){
	    	let posting = frontMemoryPattern.length.toString();
	        post.setValue("Length of front pattern memory: "+posting);
	    };
	    if(codeS[0] == "last"){
	    	editor.setValue(code_history[code_history.length-1].toString());
	    };	    	    
	    if(codeS[0] == "in"){
	        if(codeS[1] == "playAll"){
    	        editor.setValue(playAll);
	        };
	        if(codeS[1] == "stopRear"){
    	        editor.setValue(stopRear);
	        };
	        if(codeS[1] == "stopLeft"){
    	        editor.setValue(stopLeft);
	        };
	        if(codeS[1] == "stopRight"){
    	        editor.setValue(stopRight);
	        };
	        if(codeS[1] == "stopFront"){
    	        editor.setValue(stopFront);
	        };
	        if(codeS[1] == "stopAll"){
    	        editor.setValue(stopAll);
	        };
	        if(codeS[1] == "forLoop"){
    	        editor.setValue(forLoop);
	        }
	    };
	    if(codeS[0] == ".."){
	       let coding = editor.getValue();
	       code_history.push(editor.getValue());
	       eval(editor.getValue());
	       editor.setValue("");
	       //post.setValue(".. Code evaluated ..");
	       if(scoreState == 1){
			newCode = [];
	            	let endTime = new Date();
                	let timeElapsed = endTime - startTime;
                	startTime = new Date();
                	newCode.push(coding);
                    newCode.push(timeElapsed);
                	code_score.push(newCode);
                	code_score.push("\n");
                	post.setValue(".. Code saved to score ..");
	       }
	    };

	    if(codeS[0] == "frontScore"){
	      let frontShow = "frontScore = [";
	      for(let i=0;i<frontScore.length;i++){
	          frontShow += "["
	          frontShow += frontScore[i].toString();
	          frontShow += "],";
	      };
	      frontShow.substring(0,frontShow.length-1);
	      frontShow += "];"
	      editor.setValue(frontShow);  
	    };
	    
	    if(codeS[0] == "rearScore"){
	      let rearShow = "rearScore = [";
	      for(let i=0;i<rearScore.length;i++){
	          rearShow += "["
	          rearShow += rearScore[i].toString();
	          rearShow += "],";
	      };
	      rearShow.substring(0,rearShow.length-1);
	      rearShow += "];"
	      editor.setValue(rearShow);  
	    };
	    
	    if(codeS[0] == "rightScore"){
	      let rightShow = "rightScore = [";
	      for(let i=0;i<rightScore.length;i++){
	          rightShow += "["
	          rightShow += rightScore[i].toString();
	          rightShow += "],";
	      };
	      rightShow.substring(0,rightShow.length-1);
	      rightShow += "];"
	      editor.setValue(rightShow);  
	    };
	    
	    // leftScore (insert leftScore on editor)
	    if(codeS[0] == "leftScore"){
	      let leftShow = "leftScore = [";
	      for(let i=0;i<leftScore.length;i++){
	          leftShow += "["
	          leftShow += leftScore[i].toString();
	          leftShow += "],";
	      };
	      leftShow.substring(0,leftShow.length-1);
	      leftShow += "];"
	      editor.setValue(leftShow);  
	    };
	    
	    if(codeS[0] == "fullCanvas"){
	        fullCanvas();
	    }
	    
	    if(codeS[0] == "fullCanvasSynth"){
	        window.open("upigrfullCanvasSynth.html","_self");
	    }
	    
	    
	    // scale (insert scale on post)
	    
	    if(codeS[0] == "scale"){
	        post.setValue(scale.toString());
	    }
	    
	    // mtime (insert mtime on post)
	    
	    if(codeS[0] == "mtime"){
	        post.setValue(mtime.toString());
	    };
	    
	    if(codeS[0] == "rearTrans"){
	        post.setValue("rearTrans: "+rearTrans.toString());
	    };
	    
	    if(codeS[0] == "frontTrans"){
	        post.setValue("frontTrans: "+frontTrans.toString());
	    };
	    
	    // leftTrans (get left MIDI transposition sum)
	    
	    if(codeS[0] == "leftTrans"){
	        post.setValue("leftTrans: "+leftTrans.toString());
	    };
	    
	    // rightTrans (get right MIDI transposition sum)
	    
	    if(codeS[0] == "rightTrans"){
	        post.setValue("rightTrans: "+rightTrans.toString());
	    }
	        

	};
	
	// Post window

	var post= ace.edit("post");
	
	post.setOptions({
		    autoScrollEditorIntoView: true,
		    highlightActiveLine: false,
		    printMargin: false,
		    showGutter: false,
		    mode: "ace/mode/javascript",
		    theme: "ace/theme/monokai"
	});
	
	this.post.session.on('change', () => {
        this.post.renderer.scrollToLine(Number.POSITIVE_INFINITY)
    });
    
    post.session.setUseWrapMode(true);
    
    post.setValue("Welcome to uPIGr ATS 3.0\nAlgorithmic Text Sequencer\n\nType left(); on the editor window and ..+intro on the command window if do you want hear something.\n\nType functions,commands or snippets on command window for help.\n\nType download on command window for download code,docs,instruments and scores.");
    
    // Time:
     
     mtime = rint(1000,5000);
     console.log("mtime: "+mtime);
     
     mdivs = [0.75,0.5,0.375,0.25,0.125];
     //console.log("mdivs: "+mdivs);
    
     // Notes
     
     let scale = newScale();
     
     // the current front playing score:
     
     let frontScore = [];
     let frontNotes = [];
     let frontVelos = [];
     let frontTimes = [];
     
     // the current rear playing score:
     
     let rearScore = [];
     let rearNotes = [];
     let rearVelos = [];
     let rearTimes = [];

     // the current left playing score:
     
     let leftScore = [];
     let leftNotes = [];
     let leftVelos = [];
     let leftTimes = [];
     
     // the current right playing score:
     
     let rightScore = [];
     let rightNotes = [];
     let rightVelos = [];
     let rightTimes = [];
     
     // Velocity
     
     let v0 = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126];
   
     let v1 = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64];
     let v2 = [66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126];
     
     let v3 = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32];
     let v4 = [34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64];
     let v5 = [64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94];
     let v6 = [96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126];         
   
     //console.log(v0);
    
    ////////////////////////////
    // Score player
    
    let repeatscore = 1;
    let indexscore  = 0;
    let scoreStop;
    
    scoreCounter = function( ) {

       var mod = indexscore % code_score.length;

       if(!indexscore || mod || --repeatscore ) {
         indexscore = mod;
         var data = code_score[ indexscore++  ];
         
         eval(data[0]);
	       //post.setValue("From score:\n\n"+data[0]);	
	    
         scoreStop = setTimeout( scoreCounter, data[1] ); 
      }
    };

    ////////////////////////////
    // rear Counter
    // MIDI Channel 1
    
    let rear1 = "";
    
    let repeatrear = 0;
    let indexrear  = 0;
    let rearStop;
    let rearTrans = -12;
    
    rearData = [];
    rearNotes = [];
    
    rear = function( ) {

       var mod = indexrear % rearScore.length;
       let lnote = [];
       let MIDIlnote = [];
       if(!indexrear || mod || --repeatrear ) {
         indexrear = mod;
         var data = rearScore[ indexrear++  ];
         if(data[0].length != null){
             //console.log("Acorde");
             for(let i=0;i<data[0].length;i++){
                 MIDIlnote.push(Tone.Midi(data[0][i] + parseInt(rearTrans)).toMidi());
                 lnote.push(Tone.Midi(data[0][i] + parseInt(rearTrans)).toFrequency());
                 //console.log(lnote)
             }
         }else{
            lnote = [Tone.Midi(data[0] + parseInt(rearTrans)).toFrequency()];
	    MIDIlnote = [Tone.Midi(data[0] + parseInt(rearTrans)).toMidi()];
         };
	    
         MIDIchannel1.playNote(MIDIlnote,{duration: data[1],rawAttack: data[2]});	
	 //console.log("MIDI Channel 1: "+MIDIlnote+" : "+data[1]+" : "+data[2]);	
 
         rearData = [lnote,data[1]/1000,reescale(data[2],0,127,0.0,1.0)];
	 rearNotes = lnote;
         rearStop = setTimeout( rear, data[1] );
         
         if(indexrear == 1){
             eval(rear1);
         }
      }
    };


    ////////////////////////////
    // Left Counter
    // MIDI Channel 2
    
    let left1 = "";
    
    let repeatleft = 0;
    let indexleft  = 0;
    let leftStop;
    let leftTrans = 0;
    
    leftData = [];
    leftNotes = [];
    
    left = function( ) {

       var mod = indexleft % leftScore.length;
       let lnote = [];
       let MIDIlnote = [];
       if(!indexleft || mod || --repeatleft ) {
         indexleft = mod;
         var data = leftScore[ indexleft++  ];
         if(data[0].length != null){
             //console.log("Acorde");
             for(let i=0;i<data[0].length;i++){
                 MIDIlnote.push(Tone.Midi(data[0][i] + parseInt(leftTrans)).toMidi());
                 lnote.push(Tone.Midi(data[0][i] + parseInt(leftTrans)).toFrequency());
                 //console.log(lnote)
             }
         }else{
            lnote = [Tone.Midi(data[0] + parseInt(leftTrans)).toFrequency()];
	    MIDIlnote = [Tone.Midi(data[0] + parseInt(leftTrans)).toMidi()];
         };
	    
         MIDIchannel2.playNote(MIDIlnote,{duration: data[1],rawAttack: data[2]});	
	 //console.log("MIDI Channel 1: "+MIDIlnote+" : "+data[1]+" : "+data[2]);	
 
         leftData = [lnote,data[1]/1000,reescale(data[2],0,127,0.0,1.0)];
	 leftNotes = lnote;
         leftStop = setTimeout( left, data[1] );
         
         if(indexleft == 1){
             eval(left1);
         }
      }
    };
    
    ////////////////////////////
    // right Counter
    // MIDI Channel 3
    
    let right1 = "";
    
    let repeatright = 0;
    let indexright  = 0;
    let rightStop;
    let rightTrans = 12;
    
    rightData = [];
    rightNotes = [];
    
    right = function( ) {

       var mod = indexright % rightScore.length;
       let lnote = [];
       let MIDIlnote = [];
       if(!indexright || mod || --repeatright ) {
         indexright = mod;
         var data = rightScore[ indexright++  ];
         if(data[0].length != null){
             //console.log("Acorde");
             for(let i=0;i<data[0].length;i++){
                 MIDIlnote.push(Tone.Midi(data[0][i] + parseInt(rightTrans)).toMidi());
                 lnote.push(Tone.Midi(data[0][i] + parseInt(rightTrans)).toFrequency());
                 //console.log(lnote)
             }
         }else{
            lnote = [Tone.Midi(data[0] + parseInt(rightTrans)).toFrequency()];
	    MIDIlnote = [Tone.Midi(data[0] + parseInt(rightTrans)).toMidi()];
         };
	    
         MIDIchannel3.playNote(MIDIlnote,{duration: data[1],rawAttack: data[2]});	
	 //console.log("MIDI Channel 1: "+MIDIlnote+" : "+data[1]+" : "+data[2]);	
 
         rightData = [lnote,data[1]/1000,reescale(data[2],0,127,0.0,1.0)];
	 rightNotes = lnote;
         rightStop = setTimeout( right, data[1] );
         
         if(indexright == 1){
             eval(right1);
         }
      }
    };
    
    ////////////////////////////
    // front Counter
    // MIDI Channel 4
    
    let front1 = "";
    
    let repeatfront = 0;
    let indexfront  = 0;
    let frontStop;
    let frontTrans = 24;
    
    frontData = [];
    frontNotes = [];
    
    front = function( ) {

       var mod = indexfront % frontScore.length;
       let lnote = [];
       let MIDIlnote = [];
       if(!indexfront || mod || --repeatfront ) {
         indexfront = mod;
         var data = frontScore[ indexfront++  ];
         if(data[0].length != null){
             //console.log("Acorde");
             for(let i=0;i<data[0].length;i++){
                 MIDIlnote.push(Tone.Midi(data[0][i] + parseInt(frontTrans)).toMidi());
                 lnote.push(Tone.Midi(data[0][i] + parseInt(frontTrans)).toFrequency());
                 //console.log(lnote)
             }
         }else{
            lnote = [Tone.Midi(data[0] + parseInt(frontTrans)).toFrequency()];
	    MIDIlnote = [Tone.Midi(data[0] + parseInt(frontTrans)).toMidi()];
         };
	    
         MIDIchannel4.playNote(MIDIlnote,{duration: data[1],rawAttack: data[2]});	
	 //console.log("MIDI Channel 1: "+MIDIlnote+" : "+data[1]+" : "+data[2]);	
 
         frontData = [lnote,data[1]/1000,reescale(data[2],0,127,0.0,1.0)];
	 frontNotes = lnote;
         frontStop = setTimeout( front, data[1] );
         
         if(indexfront == 1){
             eval(front1);
         }
      }
    };
   
    ////////////////////////////
    // Snippets

    let playAll = "left();\nright();\nrear();\nfront();"
    
    let stopAll = "clearTimeout(leftStop);\nclearTimeout(rightStop);\nclearTimeout(rearStop);\nclearTimeout(frontStop);";
    let stopRear = "clearTimeout(rearStop);";
    let stopLeft = "clearTimeout(leftStop);";
    let stopRight = "clearTimeout(rightStop);";
    let stopFront = "clearTimeout(frontStop)";
    
    let forLoop = "for(i=0; i<12; i++){\n\n};";
    
        
    ////////////////////////////
    // Helps
    
    let help_list =  'uPIGr Algorithmic Text Sequencer Version 1\nJavascript Implementation\n\nType functions on command line for info.\nType variables on command line for info.\nType commands on command line for info.\nType snippets on command line for info.\n\nGUI parts:\n\n- Code editor.\n- Command line.\n- Post window.\n\n- Audio controls.\n- Javascript Console.';

    var commands_list = 'Commands\n\n-- Control Commands --\n\n- ..\n\n- openScore \n- initScore\n- saveScore\n\n-- Insert Commands --\n\n- in name of snippet (insert snippet on code editor)\n- i number (insert number of code history on code editor)\n- last (insert last code of code history on code editor)\n- insert (insert code on editor)\n\n-- Info Commands --\n\n- leftScore (show leftScore)\n- rightScroe (show rightScore)\n- showHistory (show code history)\n- last (post last function on code editor)\n- leftLen (show length of left memory)\n- rightLen (show length of right memory)\n- leftPatternLen (show length of left pattern memory)\n- rightPatternLen (show length of right pattern memory)';
    
    
     
     let variables_list = "- General variables:\n\n- mtime = rint(1000,5000); || General time in milliseconds.\n- mdivs = [1,0.75,0.5,0.375,0.25,0.125]; || All notes times.\n- scale || General MIDI scale.\n- leftScore || Current left score.\n- rightScore || Current right score.";
    
    let functions_list = 'Functions\n\n- left() : init left counter.\n- right() : init right counter. \n\n- newLeft(timeAlt,notesTimes,velocity,silence)\nnewLeft(modis[rint(0,modis.length-1)],mdivs,velos[rint(0,velos.length-1)],rint(0,24));\n\n- newRight(timeAlt,notesTimes,velocity,silence)\nnewRight(modis[rint(0,modis.length-1)],mdivs,velos[rint(0,velos.length-1)],rint(0,24));\n\n- leftPattern(number,repo) Create a random pattern from repo leftMemory and number length \nleftPattern(rint(4,12),[0,1,2,3,4,5,6,7,8,9,10,11])\n\n- rightPattern(number,repo) Create a random pattern from repo rightNemory and number length \nrightPattern(rint(4,12),[0,1,2,3,4,5,6,7,8,9,10,11])\n  \n- leftDrone(mtimeAlt,velocity) : Make a drone type\n    - mtimeAlt (multiplier or divisor of mtime) TIP: Large times (+1000) but cnstrain to sample duration.\n    - velocity (array of possible velocitys)\n    \n- rightDrone(mtimeAlt,velocity) : Make a drone type\n    - mtimeAlt (multiplier or divisor of mtime) TIP: Large times (+1000) but cnstrain to sample duration.\n    - velocity (array of possible velocitys)\n    \n- getLeft(int) Get int score from leftMemory\n- getRight(int) Get int score from rightMemory\n- getLeftPattern(int) Get int score from leftMemoryPattern\n- getRightPattern(int) Get int score from rightMemoryPattern\n\n- setLeftTrans(number) : Transpose MIDI left counter number (Default:0)\n- setRightTrans(number) : Transpose MIDI right counter number (Default:12)\n  \n- randomNoteLeft(): Replace one random note of leftScore\n- randomNoteRight(): Replace one random note of rightScore\n\n- loadInstrument(name) : Load Instrument\n\n';
    
    let snippets_list = "Code Snippets.\n\n- playAll (play all counters)\n- stopAll (stop all counters)\n- forLoop (javascript for loop)";
    
    
    ////////////////////////////
    // Functions
    
    // Reescale function
    
    function reescale(value, low1, high1, low2, high2) {
    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
    };
    
    // Random functions

    function rint(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1) + min);
    };

    function rfloat(min, max) {
      return Math.random() * (max - min) + min;
    };
    
    // Find divisors of int
    
    function divisors(integer) {
        var result = [];
        for(let i = 2; i < integer; i++) {
          if(integer % i == 0) {
        result.push(i)
      }
    }
     return result;
    };
    
    // Find all combinations that
    // sum to a given value
 
    function combinationSum(arr, sum) {
        let ans = new Array();
        let temp = new Array();
        let set = new Set([...arr]);
        arr = [...set];
        arr.sort()
         findNumbers(ans, arr, sum, 0, temp);
        return ans;
    };
 
    function findNumbers(ans, arr, sum, index, temp) {
         if (sum == 0) {
             ans.push([...temp]);
            return;
        }
         for (let i = index; i < arr.length; i++) {
                 if ((sum - arr[i]) >= 0) {
                    temp.push(arr[i]);
                     findNumbers(ans, arr, sum - arr[i], i, temp);
             temp.splice(temp.indexOf(arr[i]), 1);
            }
        }
    };
    
    // Function for shuffle array

    function arrayShuffle(array) {  
        var m = array.length, t, i;
        while (m) {     
          i = Math.floor(Math.random() * m--);
	        t = array[m];
	        array[m] = array[i];
	        array[i] = t;
		}
	   return array;
    };
    
    
    
    // Function for create a random scale (needs teoria.js)
    
    function newScale() {
        
        // 1. Root note
        notes = ['C','D','E','F','G','A','B'];
        root_note = teoria.note(notes[rint(0,notes.length-1)]);
        root_note_string = root_note.toString();
        //console.log(root_note_string);

        // 2. Scales

        scales = teoria.Scale.KNOWN_SCALES;
        //console.log(scales);

        // 3. Select random scale

        scale_random = scales[rint(0,scales.length-1)];

        mscale = root_note.scale(scale_random);
        //console.log(mscale);

        scale_array = mscale.simple();
        
        scaleMIDI = [];

        for(let i=0;i<scale_array.length;i++){
            scaleMIDI.push(teoria.note(scale_array[i]).midi());
        };
        
        scaleMIDIout = scaleMIDI.sort();
        
        //console.log(scaleMIDIout);
        return scaleMIDIout;
        
    };
    
    
    // setLeftTrans(number) : Transpose MIDI left counter number (Dafault:0)
    
    function setLeftTrans(number){
        leftTrans = number;
        
    };
    
    // setRightTrans(number) : Transpose MIDI right counter number (Dafault:12)
    
    function setRightTrans(number){
        rightTrans = number;
        
    };
    
    function setRearTrans(number){
        rearTrans = number;
        
    };
    
    function setFrontTrans(number){
        frontTrans = number;
        
    };

    // Make random 12 lefts and rights on init:
    
    let modis = ["/4","/2","x1","x2","x3"];
    let velos = [v0,v1,v2,v3,v4,v5,v6];
     
    for(let i=0;i<12;i++){
      newLeft(modis[rint(0,modis.length-1)],mdivs,velos[rint(0,velos.length-1)],rint(0,24));  
    };
    
    for(let i=0;i<12;i++){
      newRight(modis[rint(0,modis.length-1)],mdivs,velos[rint(0,velos.length-1)],rint(0,24));  
    };

    for(let i=0;i<12;i++){
      newRear(modis[rint(0,modis.length-1)],mdivs,velos[rint(0,velos.length-1)],rint(0,24));  
    };
    
    for(let i=0;i<12;i++){
      newFront(modis[rint(0,modis.length-1)],mdivs,velos[rint(0,velos.length-1)],rint(0,24));  
    };    
   
    // Make a random 12 leftsPatterns and Rights on init:
    
    //for(let i=0;i<12;i++){
	//leftPattern(rint(4,12),[0,1,2,3,4,5,6,7,8,9,10,11]);
    //};
    
    //for(let i=0;i<12;i++){
	//rightPattern(rint(4,12),[0,1,2,3,4,5,6,7,8,9,10,11]);
    //};
    
    function newRear(timeAlt,notesTimes,velocity,silence){
	
	let newTime = mtime;

	   let timeAltOperator = timeAlt.substring(1);

        if(timeAlt[0] == "/"){
		newTime = mtime / timeAltOperator;
	};
        if(timeAlt[0] == "x"){
		newTime = mtime * timeAltOperator;
	};
	
	//console.log("mtime: "+mtime);
	//console.log("newTime: "+newTime);

    let suming = 0;
	let pre = 0;
	let newTimesNorm = [];
	
	let i = 0.0;
	
	do {
  		pre = notesTimes[rint(0,notesTimes.length-1)];
  		newTimesNorm.push(pre);
  		i = i + pre;
	}
	while (i < 1.0);
	
	//console.log("newTimesNorm: "+newTimesNorm);
	
	let newTimes = [];
	
     	for(let i=0;i<newTimesNorm.length;i++){
             newTimes.push(newTimesNorm[i]*newTime);
        };
        
        //console.log("newTimes: "+newTimes);
                
        let newArray = [];
    
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i] = [];
        };
    
        // Add notes to newArray
        
        let newNotes = [];
        
        for (let i = 0; i < newTimes.length; i++) {
            let nooote = scale[rint(0,scale.length-1)]; 
            newNotes.push(nooote);
            newArray[i][0] = nooote;
        };
        
        //console.log("newArray: "+newArray);
        
        // Add times to newArray
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i][1] = newTimes[i];
        };
        
        //console.log("newArray: "+newArray);
        
        // Add velocitys to newArray
        
        let newVelos = [];
        let newVeloc = [];
        
        newVeloc = [...velocity];
        
        for(let i = 0;i < silence;i++){
        	newVeloc.push(0);
        };
        
        //console.log("silence: "+silence);
        //console.log("newVelos: "+newVelos);
        
        for (let i = 0; i < newTimes.length; i++) {
            let velooo = newVeloc[rint(0,newVeloc.length-1)];
            newArray[i][2] = velooo;
            newVelos.push(velooo);
        };
         
         //console.log("newArray: "+newArray);
         
         // Add to rearMemory
         
         rearMemory.push(newArray);
         
         
         // Apply to playing score
         
         rearTimes = newTimes;
         rearVelos = newVelos;
         rearNotes = newNotes;
         
         rearScore = newArray;
    };
    
    function newFront(timeAlt,notesTimes,velocity,silence){
	
	let newTime = mtime;

	   let timeAltOperator = timeAlt.substring(1);

        if(timeAlt[0] == "/"){
		newTime = mtime / timeAltOperator;
	};
        if(timeAlt[0] == "x"){
		newTime = mtime * timeAltOperator;
	};
	
	//console.log("mtime: "+mtime);
	//console.log("newTime: "+newTime);

    let suming = 0;
	let pre = 0;
	let newTimesNorm = [];
	
	let i = 0.0;
	
	do {
  		pre = notesTimes[rint(0,notesTimes.length-1)];
  		newTimesNorm.push(pre);
  		i = i + pre;
	}
	while (i < 1.0);
	
	//console.log("newTimesNorm: "+newTimesNorm);
	
	let newTimes = [];
	
     	for(let i=0;i<newTimesNorm.length;i++){
             newTimes.push(newTimesNorm[i]*newTime);
        };
        
        //console.log("newTimes: "+newTimes);
                
        let newArray = [];
    
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i] = [];
        };
    
        // Add notes to newArray
        
        let newNotes = [];
        
        for (let i = 0; i < newTimes.length; i++) {
            let nooote = scale[rint(0,scale.length-1)]; 
            newNotes.push(nooote);
            newArray[i][0] = nooote;
        };
        
        //console.log("newArray: "+newArray);
        
        // Add times to newArray
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i][1] = newTimes[i];
        };
        
        //console.log("newArray: "+newArray);
        
        // Add velocitys to newArray
        
        let newVelos = [];
        let newVeloc = [];
        
        newVeloc = [...velocity];
        
        for(let i = 0;i < silence;i++){
        	newVeloc.push(0);
        };
        
        //console.log("silence: "+silence);
        //console.log("newVelos: "+newVelos);
        
        for (let i = 0; i < newTimes.length; i++) {
            let velooo = newVeloc[rint(0,newVeloc.length-1)];
            newArray[i][2] = velooo;
            newVelos.push(velooo);
        };
         
         //console.log("newArray: "+newArray);
         
         // Add to frontMemory
         
         frontMemory.push(newArray);
         
         
         // Apply to playing score
         
         frontTimes = newTimes;
         frontVelos = newVelos;
         frontNotes = newNotes;
         
         frontScore = newArray;
    };
    

    // newLeft(timeAlt,notesTimes,velocity,silence)

    function newLeft(timeAlt,notesTimes,velocity,silence){
	
	let newTime = mtime;

	   let timeAltOperator = timeAlt.substring(1);

        if(timeAlt[0] == "/"){
		newTime = mtime / timeAltOperator;
	};
        if(timeAlt[0] == "x"){
		newTime = mtime * timeAltOperator;
	};
	
	//console.log("mtime: "+mtime);
	//console.log("newTime: "+newTime);

    let suming = 0;
	let pre = 0;
	let newTimesNorm = [];
	
	let i = 0.0;
	
	do {
  		pre = notesTimes[rint(0,notesTimes.length-1)];
  		newTimesNorm.push(pre);
  		i = i + pre;
	}
	while (i < 1.0);
	
	//console.log("newTimesNorm: "+newTimesNorm);
	
	let newTimes = [];
	
     	for(let i=0;i<newTimesNorm.length;i++){
             newTimes.push(newTimesNorm[i]*newTime);
        };
        
        //console.log("newTimes: "+newTimes);
                
        let newArray = [];
    
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i] = [];
        };
    
        // Add notes to newArray
        
        let newNotes = [];
        
        for (let i = 0; i < newTimes.length; i++) {
            let nooote = scale[rint(0,scale.length-1)]; 
            newNotes.push(nooote);
            newArray[i][0] = nooote;
        };
        
        //console.log("newArray: "+newArray);
        
        // Add times to newArray
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i][1] = newTimes[i];
        };
        
        //console.log("newArray: "+newArray);
        
        // Add velocitys to newArray
        
        let newVelos = [];
        let newVeloc = [];
        
        newVeloc = [...velocity];
        
        for(let i = 0;i < silence;i++){
        	newVeloc.push(0);
        };
        
        //console.log("silence: "+silence);
        //console.log("newVelos: "+newVelos);
        
        for (let i = 0; i < newTimes.length; i++) {
            let velooo = newVeloc[rint(0,newVeloc.length-1)];
            newArray[i][2] = velooo;
            newVelos.push(velooo);
        };
         
         //console.log("newArray: "+newArray);
         
         // Add to leftMemory
         
         leftMemory.push(newArray);
         
         
         // Apply to playing score
         
         leftTimes = newTimes;
         leftVelos = newVelos;
         leftNotes = newNotes;
         
         leftScore = newArray;
    };
    
    // newRight
    
    function newRight(timeAlt,notesTimes,velocity,silence){
	
	let newTime = mtime;

	   let timeAltOperator = timeAlt.substring(1);

        if(timeAlt[0] == "/"){
		newTime = mtime / timeAltOperator;
	};
        if(timeAlt[0] == "x"){
		newTime = mtime * timeAltOperator;
	};
	
	//console.log("mtime: "+mtime);
	//console.log("newTime: "+newTime);

    let suming = 0;
	let pre = 0;
	let newTimesNorm = [];
	
	let i = 0.0;
	
	do {
  		pre = notesTimes[rint(0,notesTimes.length-1)];
  		newTimesNorm.push(pre);
  		i = i + pre;
	}
	while (i < 1.0);
	
	//console.log("newTimesNorm: "+newTimesNorm);
	
	let newTimes = [];
	
     	for(let i=0;i<newTimesNorm.length;i++){
             newTimes.push(newTimesNorm[i]*newTime);
        };
        
        //console.log("newTimes: "+newTimes);
                
        let newArray = [];
    
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i] = [];
        };
    
        // Add notes to newArray
        
        let newNotes = [];
        
        for (let i = 0; i < newTimes.length; i++) {
            let nooote = scale[rint(0,scale.length-1)]; 
            newNotes.push(nooote);
            newArray[i][0] = nooote;
        };
        
        //console.log("newArray: "+newArray);
        
        // Add times to newArray
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i][1] = newTimes[i];
        };
        
        //console.log("newArray: "+newArray);
        
        // Add velocitys to newArray
        
        let newVelos = [];
        let newVeloc = [];
        
        newVeloc = [...velocity];
        
        for(let i = 0;i < silence;i++){
        	newVeloc.push(0);
        };
        
        //console.log("silence: "+silence);
        //console.log("newVelos: "+newVelos);
        
        for (let i = 0; i < newTimes.length; i++) {
            let velooo = newVeloc[rint(0,newVeloc.length-1)];
            newArray[i][2] = velooo;
            newVelos.push(velooo);
        };
         
         //console.log("newArray: "+newArray);
         
         // Add to leftMemory
         
         rightMemory.push(newArray);
         
         // Apply to playing score
         
         rightTimes = newTimes;
         rightVelos = newVelos;
         rightNotes = newNotes;
         
         rightScore = newArray;
    };

    function rearPattern(patternNumber,repo){
        
        let repoArray = [];
        let len = 0;

        for(let i = 0; i < patternNumber;i++){
            let noo = repo[rint(0,repo.length-1)];
            repoArray.push(noo);
            len = len + rearMemory[noo].length;
        };        
        
        let newArray = [];
    
        for (let i = 0; i < len; i++) {
            newArray[i] = [];
        };
        
        // Add notes
        
        let newNotes = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = rearMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let noote = rearMemory[repoArray[i]][j][0];
                 newNotes.push(noote);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][0] = newNotes[i];
        }
        
        
        // Add times
        
        let newTimes = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = rearMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let length = rearMemory[repoArray[i]][j][1];
                 newTimes.push(length);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][1] = newTimes[i];
        }
        
        // Add velos
        
        let newVelos = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = rearMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let velo = rearMemory[repoArray[i]][j][2];
                 newVelos.push(velo);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][2] = newVelos[i];
        }
        
         // Add to rearMemoryPattern
         
         rearMemoryPattern.push(newArray);
         
         // Apply to playing score
         
         rearTimes = newTimes;
         rearVelos = newVelos;
         rearNotes = newNotes;
         
         rearScore = newArray;          
        
        };

    function frontPattern(patternNumber,repo){
        
        let repoArray = [];
        let len = 0;

        for(let i = 0; i < patternNumber;i++){
            let noo = repo[rint(0,repo.length-1)];
            repoArray.push(noo);
            len = len + frontMemory[noo].length;
        };        
        
        let newArray = [];
    
        for (let i = 0; i < len; i++) {
            newArray[i] = [];
        };
        
        // Add notes
        
        let newNotes = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = frontMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let noote = frontMemory[repoArray[i]][j][0];
                 newNotes.push(noote);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][0] = newNotes[i];
        }
        
        
        // Add times
        
        let newTimes = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = frontMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let length = frontMemory[repoArray[i]][j][1];
                 newTimes.push(length);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][1] = newTimes[i];
        }
        
        // Add velos
        
        let newVelos = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = frontMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let velo = frontMemory[repoArray[i]][j][2];
                 newVelos.push(velo);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][2] = newVelos[i];
        }
        
         // Add to frontMemoryPattern
         
         frontMemoryPattern.push(newArray);
         
         // Apply to playing score
         
         frontTimes = newTimes;
         frontVelos = newVelos;
         frontNotes = newNotes;
         
         frontScore = newArray;          
        
        };

    
    function leftPattern(patternNumber,repo){
        
        let repoArray = [];
        let len = 0;

        for(let i = 0; i < patternNumber;i++){
            let noo = repo[rint(0,repo.length-1)];
            repoArray.push(noo);
            len = len + leftMemory[noo].length;
        };        
        
        let newArray = [];
    
        for (let i = 0; i < len; i++) {
            newArray[i] = [];
        };
        
        // Add notes
        
        let newNotes = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = leftMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let noote = leftMemory[repoArray[i]][j][0];
                 newNotes.push(noote);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][0] = newNotes[i];
        }
        
        
        // Add times
        
        let newTimes = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = leftMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let length = leftMemory[repoArray[i]][j][1];
                 newTimes.push(length);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][1] = newTimes[i];
        }
        
        // Add velos
        
        let newVelos = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = leftMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let velo = leftMemory[repoArray[i]][j][2];
                 newVelos.push(velo);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][2] = newVelos[i];
        }
        
         // Add to leftMemoryPattern
         
         leftMemoryPattern.push(newArray);
         
         // Apply to playing score
         
         leftTimes = newTimes;
         leftVelos = newVelos;
         leftNotes = newNotes;
         
         leftScore = newArray;          
        
        };

        
    // rightPattern(number,repo) Create a random pattern from repo rightNemory and number length 
    // rightPattern(rint(4,12),[0,1,2,3,4,5,6,7,8,9,10,11])
    
    function rightPattern(patternNumber,repo){
        
        let repoArray = [];
        let len = 0;

        for(let i = 0; i < patternNumber;i++){
            let noo = repo[rint(0,repo.length-1)];
            repoArray.push(noo);
            len = len + rightMemory[noo].length;
        };        
        
        let newArray = [];
    
        for (let i = 0; i < len; i++) {
            newArray[i] = [];
        };
        
        // Add notes
        
        let newNotes = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = rightMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let noote = rightMemory[repoArray[i]][j][0];
                 newNotes.push(noote);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][0] = newNotes[i];
        }
        
        
        // Add times
        
        let newTimes = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = rightMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let length = rightMemory[repoArray[i]][j][1];
                 newTimes.push(length);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][1] = newTimes[i];
        }
        
        // Add velos
        
        let newVelos = [];
        
        for (let i = 0; i < patternNumber; i++) {
            let memoryLengths = rightMemory[repoArray[i]].length;
             for (let j = 0; j < memoryLengths; j++) {
                 let velo = rightMemory[repoArray[i]][j][2];
                 newVelos.push(velo);
             }
        };
        
        for (let i = 0; i < len; i++) {
            newArray[i][2] = newVelos[i];
        }
        
         // Add to rightMemoryPattern
         
         rightMemoryPattern.push(newArray);
         
         // Apply to playing score
         
         rightTimes = newTimes;
         rightVelos = newVelos;
         rightNotes = newNotes;
         
         rightScore = newArray;          
        
        }
    

    
    // leftDrone(mtimeAlt,velocity) : Make a drone type
    // - mtimeAlt (multiplier or divisor of mtime) TIP: Large times (+1000) but cnstrain to sample duration.
    // - velocity (array of possible velocitys)
    
    function leftDrone(timeAlt,velocity){
        
       let newTime = mtime;

	   let timeAltOperator = timeAlt.substring(1);

        if(timeAlt[0] == "/"){
		    newTime = mtime / timeAltOperator;
	    };
        if(timeAlt[0] == "x"){
		    newTime = mtime * timeAltOperator;
	    };
	    
	    let repes = rint(2,6);
	    
	    let newTimes = [];
	
     	for(let i=0;i<repes;i++){
             newTimes.push(newTime);
        };
        
        let newArray = [];
    
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i] = [];
        };
    
        // Add notes to newArray
        
        let newNotes = [];
        
        let nooote = scale[rint(0,scale.length-1)]; 
        
        for (let i = 0; i < newTimes.length; i++) {
                newNotes.push(nooote);
                newArray[i][0] = nooote;
        };
        
        //console.log("newArray: "+newArray);
        
        // Add times to newArray
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i][1] = newTimes[i];
        };
        
        //console.log("newArray: "+newArray);
        
        // Add velocitys to newArray
        
        let newVelos = [];
        
        newVeloc = [...velocity];
        
        let velooo = newVeloc[rint(0,newVeloc.length-1)];
        
        for (let i = 0; i < newTimes.length; i++) {
            
            newArray[i][2] = velooo;
            newVelos.push(velooo);
        };
	   
         // Add to leftMemory
         
         leftMemoryDrone.push(newArray);
         
         // Apply to playing score
         
         leftTimes = newTimes;
         leftVelos = newVelos;
         leftNotes = newNotes;
         
         leftScore = newArray;
    };
    
    function rearDrone(timeAlt,velocity){
        
       let newTime = mtime;

	   let timeAltOperator = timeAlt.substring(1);

        if(timeAlt[0] == "/"){
		    newTime = mtime / timeAltOperator;
	    };
        if(timeAlt[0] == "x"){
		    newTime = mtime * timeAltOperator;
	    };
	    
	    let repes = rint(2,6);
	    
	    let newTimes = [];
	
     	for(let i=0;i<repes;i++){
             newTimes.push(newTime);
        };
        
        let newArray = [];
    
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i] = [];
        };
    
        // Add notes to newArray
        
        let newNotes = [];
        
        let nooote = scale[rint(0,scale.length-1)]; 
        
        for (let i = 0; i < newTimes.length; i++) {
                newNotes.push(nooote);
                newArray[i][0] = nooote;
        };
        
        //console.log("newArray: "+newArray);
        
        // Add times to newArray
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i][1] = newTimes[i];
        };
        
        //console.log("newArray: "+newArray);
        
        // Add velocitys to newArray
        
        let newVelos = [];
        
        newVeloc = [...velocity];
        
        let velooo = newVeloc[rint(0,newVeloc.length-1)];
        
        for (let i = 0; i < newTimes.length; i++) {
            
            newArray[i][2] = velooo;
            newVelos.push(velooo);
        };
	   
         // Add to rearMemory
         
         rearMemoryDrone.push(newArray);
         
         // Apply to playing score
         
         rearTimes = newTimes;
         rearVelos = newVelos;
         rearNotes = newNotes;
         
         rearScore = newArray;
    };

    function frontDrone(timeAlt,velocity){
        
       let newTime = mtime;

	   let timeAltOperator = timeAlt.substring(1);

        if(timeAlt[0] == "/"){
		    newTime = mtime / timeAltOperator;
	    };
        if(timeAlt[0] == "x"){
		    newTime = mtime * timeAltOperator;
	    };
	    
	    let repes = rint(2,6);
	    
	    let newTimes = [];
	
     	for(let i=0;i<repes;i++){
             newTimes.push(newTime);
        };
        
        let newArray = [];
    
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i] = [];
        };
    
        // Add notes to newArray
        
        let newNotes = [];
        
        let nooote = scale[rint(0,scale.length-1)]; 
        
        for (let i = 0; i < newTimes.length; i++) {
                newNotes.push(nooote);
                newArray[i][0] = nooote;
        };
        
        //console.log("newArray: "+newArray);
        
        // Add times to newArray
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i][1] = newTimes[i];
        };
        
        //console.log("newArray: "+newArray);
        
        // Add velocitys to newArray
        
        let newVelos = [];
        
        newVeloc = [...velocity];
        
        let velooo = newVeloc[rint(0,newVeloc.length-1)];
        
        for (let i = 0; i < newTimes.length; i++) {
            
            newArray[i][2] = velooo;
            newVelos.push(velooo);
        };
	   
         // Add to frontMemory
         
         frontMemoryDrone.push(newArray);
         
         // Apply to playing score
         
         frontTimes = newTimes;
         frontVelos = newVelos;
         frontNotes = newNotes;
         
         frontScore = newArray;
    };
        
        
    
    // RightDrone
 
    function rightDrone(timeAlt,velocity){
        
       let newTime = mtime;

	   let timeAltOperator = timeAlt.substring(1);

        if(timeAlt[0] == "/"){
		    newTime = mtime / timeAltOperator;
	    };
        if(timeAlt[0] == "x"){
		    newTime = mtime * timeAltOperator;
	    };
	    
	    let repes = rint(2,6);
	    
	    let newTimes = [];
	
     	for(let i=0;i<repes;i++){
             newTimes.push(newTime);
        };
        
        let newArray = [];
    
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i] = [];
        };
    
        // Add notes to newArray
        
        let newNotes = [];
        
        let nooote = scale[rint(0,scale.length-1)]; 
        
        for (let i = 0; i < newTimes.length; i++) {
                newNotes.push(nooote);
                newArray[i][0] = nooote;
        };
        
        //console.log("newArray: "+newArray);
        
        // Add times to newArray
        for (let i = 0; i < newTimes.length; i++) {
            newArray[i][1] = newTimes[i];
        };
        
        //console.log("newArray: "+newArray);
        
        // Add velocitys to newArray
        
        let newVelos = [];
        
        newVeloc = [...velocity];
        
        let velooo = newVeloc[rint(0,newVeloc.length-1)];
        
        for (let i = 0; i < newTimes.length; i++) {
            
            newArray[i][2] = velooo;
            newVelos.push(velooo);
        };
	   
         // Add to rightMemory
         
         rightMemoryDrone.push(newArray);
         
         // Apply to playing score
         
         rightTimes = newTimes;
         rightVelos = newVelos;
         rightNotes = newNotes;
         
         rightScore = newArray;
    };

    function getRear(memo){
        rearScore = rearMemory[memo];
        //console.log(rearMemory[memo]);
    };
    

    function getFront(memo){
        frontScore = frontMemory[memo];
        //console.log(frontMemory[memo]);
    };
 
    // getLeft(int) Get int score from leftMemory
    
    function getLeft(memo){
        leftScore = leftMemory[memo];
        //console.log(leftMemory[memo]);
    };

    // getRight(int) Get int score from rightMemory
    
    function getRight(memo){
        rightScore = rightMemory[memo];
        //console.log(rightMemory[memo]);
    };
    
    // getLeftPattern(int) Get int score from leftMemoryPattern
    
    function getLeftPattern(memo){
        leftScore = leftMemoryPattern[memo];
        //console.log(leftMemory[memo]);
    };

    // getRightPattern(int) Get int score from rightMemoryPattern
    
    function getRightPattern(memo){
        rightScore = rightMemoryPattern[memo];
        //console.log(rightMemory[memo]);
    };
    
    function getRearPattern(memo){
        rearScore = rearMemoryPattern[memo];
        //console.log(rearMemory[memo]);
    };
    
    function getFrontPattern(memo){
        frontScore = frontMemoryPattern[memo];
        //console.log(frontMemory[memo]);
    };
    
    function getLeftDrone(memo){
        leftScore = leftMemoryDrone[memo];
    };

    function getRightDrone(memo){
        rightScore = rightMemoryDrone[memo];
    };
    
    function getRearDrone(memo){
        rearScore = rearMemoryDrone[memo];
    };
    
    function getFrontDrone(memo){
        frontScore = frontMemoryDrone[memo];
    };
    

    // Function for save score

    function saveScore(name) {
          var textToWrite = "";
          
          for(var i = 0; i < code_score.length; i++) {
            for(var j = 0; j < code_score[i].length; j++) {
               //console.log("i:"+i);
               //console.log("j:"+j);
               //console.log(code_score[i][j]);
               if(j == 1){
                   textToWrite += "#";
                   textToWrite += code_score[i][j];
               }else{
                   textToWrite += "@";
                   textToWrite += code_score[i][j];
                   
               }
            }
          };
          
          
          filename = name+'-'+date()+'.js';
          var textFileAsBlob = new Blob([textToWrite], { type: "text/plain;charset=utf-8" });
          var fileNameToSaveAs = filename;
          var downloadLink = document.createElement("a"); downloadLink.download = fileNameToSaveAs; downloadLink.innerHTML = "Download File"; if (window.webkitURL != null) {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob); } else { // Firefox requires the link to be added to the DOM // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob); downloadLink.onclick = destroyClickedElement; downloadLink.style.display = "none"; document.body.appendChild(downloadLink); }
            downloadLink.click();
        };

         // insert on editor
        
        function insertonEditor(e) {
              var file = e.target.files[0];
              if (!file) {
                return;
              }
              var reader = new FileReader();
              reader.onload = function(e) {
                var contents = e.target.result;
              
              //console.log(contents);
              editor.setValue(contents);
          };
          reader.readAsText(file);
        };
        
        // Open and play score
        
        function openplayScore(e) {
              var file = e.target.files[0];
              if (!file) {
                return;
              }
              var reader = new FileReader();
              reader.onload = function(e) {
                var contents = e.target.result;
                
                
                let newCodeFile = contents.replace(/(\r\n|\n|\r)/gm, "");
                let newCodeFile1 = newCodeFile.replaceAll(/\s/g,'');
                
                
                let newCodeArray1 = newCodeFile1.split("@");
                
                let newCodeArray2 = [];
                
                newCodeArray1.map((elem) => {
                    if (elem !== '') {
                        newCodeArray2.push(elem);
                }
                });
                
                code_score = [];
                
                    
                //for (let i = 0; i < newCodeArray2.length; i++) {
                            //code_score[i] = [];
                //};
                
                for (let i = 0; i < newCodeArray2.length; i++) {
                    
                    code_score.push(newCodeArray2[i].split("#"))
                };
    
                //for(let i=0;i<newCodeFile.length//;i++){
                    
                //}
                
                console.log(newCodeArray2);
                console.log(code_score);
              };
              reader.readAsText(file);
              
                repeatscore = 1;
	            indexscore  = 0;
	            setTimeout(scoreCounter, 5000);
	            
              
        }
        
        // function for open score

          function openScore(e) {
              var file = e.target.files[0];
              if (!file) {
                return;
              }
              var reader = new FileReader();
              reader.onload = function(e) {
                var contents = e.target.result;
                
                
                let newCodeFile = contents.replace(/(\r\n|\n|\r)/gm, "");
                let newCodeFile1 = newCodeFile.replaceAll(/\s/g,'');
                
                
                let newCodeArray1 = newCodeFile1.split("@");
                
                let newCodeArray2 = [];
                
                newCodeArray1.map((elem) => {
                    if (elem !== '') {
                        newCodeArray2.push(elem);
                }
                });
                
                code_score = [];
                
                    
                //for (let i = 0; i < newCodeArray2.length; i++) {
                            //code_score[i] = [];
                //};
                
                for (let i = 0; i < newCodeArray2.length; i++) {
                    
                    code_score.push(newCodeArray2[i].split("#"))
                };
    
                //for(let i=0;i<newCodeFile.length//;i++){
                    
                //}
                
                console.log(newCodeArray2);
                console.log(code_score);
              };
              reader.readAsText(file);
        };
        
        // function for open synth

          function openSynth(e) {
              var file = e.target.files[0];
              if (!file) {
                return;
              }
              var reader = new FileReader();
              reader.onload = function(e) {
              var contents = e.target.result;
              
              console.log(contents); 
              eval(contents); 
            
              };
              reader.readAsText(file);
        };
        
        // function for command LoadInstrument

        function loadInstrument(name) {
		    eval(name); 
        };
        
        // Get Date
        function date(){
	        let date = new Date();
	        let year = date.getFullYear();
	        let month = date.getMonth()+1;
	        let day = date.getDate();
	        let hours = date.getHours();
	        let minutes = date.getMinutes();
	        let seconds = date.getSeconds();
	        let fecha = year+'-'+month+'-'+day+'_'+hours+'-'+minutes+'-'+seconds;
	        return fecha;
        };
        
        // Replace one random note of leftScore
        
        function randomNoteLeft(){
            leftScore[rint(0,leftScore.length-1)][0] = scale[rint(0,scale.length-1)];
        };
        
        // Replace one random note of rightScore
        
        function randomNoteRight(){
            rightScore[rint(0,rightScore.length-1)][0] = scale[rint(0,scale.length-1)];
        };
        
        // Replace one random note of rearScore
        
        function randomNoteRear(){
            rearScore[rint(0,rearScore.length-1)][0] = scale[rint(0,scale.length-1)];
        };
        
        // Replace one random note of frontScore
        
        function randomNoteFront(){
            frontScore[rint(0,frontScore.length-1)][0] = scale[rint(0,scale.length-1)];
        };
        
        // Replace X random notes on rearScore (on create new and add to memory)
        
        function xRandomNoteRear(number){
            
            // 1. Create a copy of current score:
            
            let newArray = [];

            for (var i = 0; i < rearScore.length; i++){
                newArray[i] = rearScore[i].slice();
            };
            
            //console.log(rearScore);
            //console.log(newArray);
            
            // 2. Transform this copy X notes
            
            let rArray = [];
            
            for (var i = 0; i < number; i++){
                 rArray.push(i);
            };
            
            //console.log(rArray);
            
            arrayShuffle(rArray);
            
            //console.log(rArray);
            
            for (var i = 0; i < number; i++){
                newArray[rArray[i]][0] = scale[rint(0,scale.length-1)];
            };
            
            //console.log(newArray);
            
            // 3. Play new array 
            
            rearScore = newArray;
    
            // 4. Add to memory 
            
            rearMemory.push(newArray);
        };
        
        // Replace X random notes on leftScore (on create new and add to memory)
        
        function xRandomNoteLeft(number){
            
            // 1. Create a copy of current score:
            
            let newArray = [];

            for (var i = 0; i < leftScore.length; i++){
                newArray[i] = leftScore[i].slice();
            };
            
            //console.log(leftScore);
            //console.log(newArray);
            
            // 2. Transform this copy X notes
            
            let rArray = [];
            
            for (var i = 0; i < number; i++){
                 rArray.push(i);
            };
            
            //console.log(rArray);
            
            arrayShuffle(rArray);
            
            //console.log(rArray);
            
            for (var i = 0; i < number; i++){
                newArray[rArray[i]][0] = scale[rint(0,scale.length-1)];
            };
            
            //console.log(newArray);
            
            // 3. Play new array 
            
            leftScore = newArray;
    
            // 4. Add to memory 
            
            leftMemory.push(newArray);
        
        };
        
        // Replace X random notes on rightScore (on create new and add to memory)
        
        function xRandomNoteRight(number){
            
            // 1. Create a copy of current score:
            
            let newArray = [];

            for (var i = 0; i < rightScore.length; i++){
                newArray[i] = rightScore[i].slice();
            };
            
            //console.log(rightScore);
            //console.log(newArray);
            
            // 2. Transform this copy X notes
            
            let rArray = [];
            
            for (var i = 0; i < number; i++){
                 rArray.push(i);
            };
            
            //console.log(rArray);
            
            arrayShuffle(rArray);
            
            //console.log(rArray);
            
            for (var i = 0; i < number; i++){
                newArray[rArray[i]][0] = scale[rint(0,scale.length-1)];
            };
            
            //console.log(newArray);
            
            // 3. Play new array 
            
            rightScore = newArray;
    
            // 4. Add to memory 
            
            rightMemory.push(newArray);
        
        };
        
        // Replace X random notes on frontScore (on create new and add to memory)
        
        function xRandomNoteFront(number){
            
            // 1. Create a copy of current score:
            
            let newArray = [];

            for (var i = 0; i < frontScore.length; i++){
                newArray[i] = frontScore[i].slice();
            };
            
            //console.log(frontScore);
            //console.log(newArray);
            
            // 2. Transform this copy X notes
            
            let rArray = [];
            
            for (var i = 0; i < number; i++){
                 rArray.push(i);
            };
            
            //console.log(rArray);
            
            arrayShuffle(rArray);
            
            //console.log(rArray);
            
            for (var i = 0; i < number; i++){
                newArray[rArray[i]][0] = scale[rint(0,scale.length-1)];
            };
            
            //console.log(newArray);
            
            // 3. Play new array 
            
            frontScore = newArray;
    
            // 4. Add to memory 
            
            frontMemory.push(newArray);
        };
        
        // Replace X random times on rearScore (on create new and add to rearMemory)
        
        // Show text on canvas:
        
        function title(txt){
            clear();
            drawing = "fill(255);textAlign(CENTER);textSize(width/40);text('"+txt+"', width/2, height/2)"
        }
        
        // fullscreen canvas
        
        function fullCanvas(){
           window.open("upigrfullCanvas.html","_self");
        }

        // Function triggered when WEBMIDI.js is ready


        function onEnabled() {

                // Display available MIDI input devices 
                if (WebMidi.inputs.length < 1) { 
                                console.log("No device detected."); 
                } else { 
                        WebMidi.inputs.forEach((device, index) => { 
                                console.log(`${index}: ${device.name}`); 
                  }); 
                 } 
 	};
 	
 	        // Override console methods to post window
        
        (()=>{
          const console_log = window.console.log;
          window.console.log = function(...args){
            console_log(...args);
            //args.forEach(arg=>post.setValue( `${JSON.stringify(arg)}\n`));
            args.forEach(arg=>post.setValue( `${arg}\n`));
        }
        })();

</script>

</body>
</html>

